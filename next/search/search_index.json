{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Gremlins \u00b6 Gremlins is a mutation testing tool for Go. It has been made to work well on smallish Go modules, for example microservices , on which it helps validate the test suite, aids the TDD process and can be used as a CI quality gate. As of now, Gremlins doesn't work very well on very big Go modules, mainly because a run can take hours to complete. Features \u00b6 Discovers mutant candidates and tests them Only tests mutants covered by tests Supports five mutant types Can run in dry run mode Yaml-based configuration","title":"Home"},{"location":"#welcome-to-gremlins","text":"Gremlins is a mutation testing tool for Go. It has been made to work well on smallish Go modules, for example microservices , on which it helps validate the test suite, aids the TDD process and can be used as a CI quality gate. As of now, Gremlins doesn't work very well on very big Go modules, mainly because a run can take hours to complete.","title":"Welcome to Gremlins"},{"location":"#features","text":"Discovers mutant candidates and tests them Only tests mutants covered by tests Supports five mutant types Can run in dry run mode Yaml-based configuration","title":"Features"},{"location":"install/","text":"Install \u00b6 Gremlins can be installed via pre-compiled binaries or from source. Pre compiled binaries \u00b6 Linux \u00b6 We don't have public repositories yet. To install, you have to download the package appropriate to your architecture/OS and install it \"manually\". deb rpm Download a .deb file appropriate for your ARCH from the release page , the install with: dpkg -i package.deb Download a .rpm file appropriate for your ARCH from the release page , the install with: rpm -i package.rpm MacOS \u00b6 On macOS, you can use Homebrew . As of now, Gremlins uses only an Homebrew tap . To install, you have to first tap Gremlins' repository: brew tap go-gremlins/tap #(1) Doing this, your tap will refer directly to the Gremlins' tap formula on GitHub. You can delete the tap by \"untapping\" it: brew untap go-gremlins/tap Then you can install it: brew install gremlins Windows \u00b6 As of now, only manual installation is supported. Download the appropriate release package from the release page , extract the zip archive and copy the .exe file somewhere in your execution PATH . Manual install \u00b6 Alternatively, you can download the binary for your ARCH/OS, untar it: tar -xvf gremlins_XXX.tar.gz then copy it somewhere in PATH : sudo cp gremlins_XXX/gremlins /usr/bin From source \u00b6 To build Gremlins you need the Go compiler , make and golangci-lint for linting. You can clone download the source tarball from the release page , then: tar -xvf gremlins_vXXX.tar.gz Ad then: cd gremlins make At this point, you can move the generated binary executable to a location of your choice.","title":"Install"},{"location":"install/#install","text":"Gremlins can be installed via pre-compiled binaries or from source.","title":"Install"},{"location":"install/#pre-compiled-binaries","text":"","title":"Pre compiled binaries"},{"location":"install/#linux","text":"We don't have public repositories yet. To install, you have to download the package appropriate to your architecture/OS and install it \"manually\". deb rpm Download a .deb file appropriate for your ARCH from the release page , the install with: dpkg -i package.deb Download a .rpm file appropriate for your ARCH from the release page , the install with: rpm -i package.rpm","title":"Linux"},{"location":"install/#macos","text":"On macOS, you can use Homebrew . As of now, Gremlins uses only an Homebrew tap . To install, you have to first tap Gremlins' repository: brew tap go-gremlins/tap #(1) Doing this, your tap will refer directly to the Gremlins' tap formula on GitHub. You can delete the tap by \"untapping\" it: brew untap go-gremlins/tap Then you can install it: brew install gremlins","title":"MacOS"},{"location":"install/#windows","text":"As of now, only manual installation is supported. Download the appropriate release package from the release page , extract the zip archive and copy the .exe file somewhere in your execution PATH .","title":"Windows"},{"location":"install/#manual-install","text":"Alternatively, you can download the binary for your ARCH/OS, untar it: tar -xvf gremlins_XXX.tar.gz then copy it somewhere in PATH : sudo cp gremlins_XXX/gremlins /usr/bin","title":"Manual install"},{"location":"install/#from-source","text":"To build Gremlins you need the Go compiler , make and golangci-lint for linting. You can clone download the source tarball from the release page , then: tar -xvf gremlins_vXXX.tar.gz Ad then: cd gremlins make At this point, you can move the generated binary executable to a location of your choice.","title":"From source"},{"location":"quick-start/","text":"Quick start \u00b6 To execute a mutation test run, from the root of a Go module execute: $ gremlins unleash #(1) If unleash is too long to type for you, you can use run or r which will do the same. Gremlins only tests mutations of parts of the code already covered by test cases. If a mutant is not covered, why bother testing? You already know it will not be caught. In any case, Gremlins will report which mutations aren't covered. Gremlins will report each mutation as: RUNNABLE : In dry-run mode, a mutation that can be tested. NOT COVERED : A mutation not covered by tests; it will not be tested. KILLED : The mutation has been caught by the test suite. LIVED : The mutation hasn't been caught by the test suite. TIMED OUT : The tests timed out while testing the mutation: the mutation actually made the tests fail, but not explicitly. NOT VIABLE : The mutation makes the build fail.","title":"Quick start"},{"location":"quick-start/#quick-start","text":"To execute a mutation test run, from the root of a Go module execute: $ gremlins unleash #(1) If unleash is too long to type for you, you can use run or r which will do the same. Gremlins only tests mutations of parts of the code already covered by test cases. If a mutant is not covered, why bother testing? You already know it will not be caught. In any case, Gremlins will report which mutations aren't covered. Gremlins will report each mutation as: RUNNABLE : In dry-run mode, a mutation that can be tested. NOT COVERED : A mutation not covered by tests; it will not be tested. KILLED : The mutation has been caught by the test suite. LIVED : The mutation hasn't been caught by the test suite. TIMED OUT : The tests timed out while testing the mutation: the mutation actually made the tests fail, but not explicitly. NOT VIABLE : The mutation makes the build fail.","title":"Quick start"},{"location":"usage/configuration/","text":"Configuration \u00b6 Gremlins can be configured via (in order of precedence): command flags environment variables configuration files Command flags \u00b6 Flags have the higher priority and override all the other means of setting behaviours. Please refer to the specific command documentation to learn how to use them. Configuration files \u00b6 Gremlins can be configured with a configuration file. Location \u00b6 The configuration file can be placed in (in order of precedence) ./.gremlins.yaml (the current directory) /etc/gremlins/gremlins.yaml $XDG_CONFIG_HOME/gremlins/gremlins.yaml $HOME/.gremlins.yaml Hint XDG_CONFIG_HOME is usually ~/.config . Override \u00b6 The config file can be overridden with the --config flag. gremlins unleash --config = myConfig.yaml Reference \u00b6 Here is a complete configuration file with all the properties set to their defaults: unleash : dry-run : false tags : \"\" threshold : #(1) efficacy : 0 mutant-coverage : 0 mutants : arithmetic-base : enabled : true conditionals-boundary : enabled : true conditionals-negation : enabled : true increment-decrement : enabled : true invert-negatives : enabled : true Thresholds are set by default to 0 , which means they are not enforced. For further information check the specific documentation. Environment variables \u00b6 Gremlins can be configured via environment variables as well. You can construct the variable name referring to the configuration file format. They start with GREMLINS_ , and each dot and dash becomes an underscore. For example: mutants : arithmetic-base : enabled : true Can be set with: export GREMLINS_MUTANTS_ARITHMETIC_BASE = true","title":"Configuration"},{"location":"usage/configuration/#configuration","text":"Gremlins can be configured via (in order of precedence): command flags environment variables configuration files","title":"Configuration"},{"location":"usage/configuration/#command-flags","text":"Flags have the higher priority and override all the other means of setting behaviours. Please refer to the specific command documentation to learn how to use them.","title":"Command flags"},{"location":"usage/configuration/#configuration-files","text":"Gremlins can be configured with a configuration file.","title":"Configuration files"},{"location":"usage/configuration/#location","text":"The configuration file can be placed in (in order of precedence) ./.gremlins.yaml (the current directory) /etc/gremlins/gremlins.yaml $XDG_CONFIG_HOME/gremlins/gremlins.yaml $HOME/.gremlins.yaml Hint XDG_CONFIG_HOME is usually ~/.config .","title":"Location"},{"location":"usage/configuration/#override","text":"The config file can be overridden with the --config flag. gremlins unleash --config = myConfig.yaml","title":"Override"},{"location":"usage/configuration/#reference","text":"Here is a complete configuration file with all the properties set to their defaults: unleash : dry-run : false tags : \"\" threshold : #(1) efficacy : 0 mutant-coverage : 0 mutants : arithmetic-base : enabled : true conditionals-boundary : enabled : true conditionals-negation : enabled : true increment-decrement : enabled : true invert-negatives : enabled : true Thresholds are set by default to 0 , which means they are not enforced. For further information check the specific documentation.","title":"Reference"},{"location":"usage/configuration/#environment-variables","text":"Gremlins can be configured via environment variables as well. You can construct the variable name referring to the configuration file format. They start with GREMLINS_ , and each dot and dash becomes an underscore. For example: mutants : arithmetic-base : enabled : true Can be set with: export GREMLINS_MUTANTS_ARITHMETIC_BASE = true","title":"Environment variables"},{"location":"usage/commands/gremlins/","text":"Gremlins \u00b6 The gremlins command works with command and flags. Think of commands as verbs and flags as adjectives. If you type gremlins a short usage summary will be printed. At any time, you can get further help writing gremlins help <command>","title":"Gremlins"},{"location":"usage/commands/gremlins/#gremlins","text":"The gremlins command works with command and flags. Think of commands as verbs and flags as adjectives. If you type gremlins a short usage summary will be printed. At any time, you can get further help writing gremlins help <command>","title":"Gremlins"},{"location":"usage/commands/unleash/","text":"Unleash \u00b6 The main command used in Gremlins is unleash , that unleashes the gremlins and start a mutation test of your code. If unleash is too long to type for you, you can use its aliases run and r . Warning At this time, this only works in the root of a Go module (where the go.mod file resides). To execute a mut ation testing run just type gremlins unleash If the module build requires tags gremlins unleash --tags \"tag1,tag2\" Flags \u00b6 unleash supports several flags to fine tune its behaviour. --dry-run \u00b6 Just performs the analysis but not the mutation testing. gremlins unleash --dry-run --tags \u00b6 --threshold-efficacy \u00b6 --threshold-mcover \u00b6 --arithmetic-base \u00b6 --conditionals-boundary \u00b6 --conditionals-negation \u00b6 --increment-decrement \u00b6 --invert-negatives \u00b6","title":"Unleash"},{"location":"usage/commands/unleash/#unleash","text":"The main command used in Gremlins is unleash , that unleashes the gremlins and start a mutation test of your code. If unleash is too long to type for you, you can use its aliases run and r . Warning At this time, this only works in the root of a Go module (where the go.mod file resides). To execute a mut ation testing run just type gremlins unleash If the module build requires tags gremlins unleash --tags \"tag1,tag2\"","title":"Unleash"},{"location":"usage/commands/unleash/#flags","text":"unleash supports several flags to fine tune its behaviour.","title":"Flags"},{"location":"usage/commands/unleash/#-dry-run","text":"Just performs the analysis but not the mutation testing. gremlins unleash --dry-run","title":"--dry-run"},{"location":"usage/commands/unleash/#-tags","text":"","title":"--tags"},{"location":"usage/commands/unleash/#-threshold-efficacy","text":"","title":"--threshold-efficacy"},{"location":"usage/commands/unleash/#-threshold-mcover","text":"","title":"--threshold-mcover"},{"location":"usage/commands/unleash/#-arithmetic-base","text":"","title":"--arithmetic-base"},{"location":"usage/commands/unleash/#-conditionals-boundary","text":"","title":"--conditionals-boundary"},{"location":"usage/commands/unleash/#-conditionals-negation","text":"","title":"--conditionals-negation"},{"location":"usage/commands/unleash/#-increment-decrement","text":"","title":"--increment-decrement"},{"location":"usage/commands/unleash/#-invert-negatives","text":"","title":"--invert-negatives"},{"location":"usage/mutations/about/","text":"About Mutations \u00b6 Mutations are the core of Gremlins' activity. Each mutation belongs to a group that defines its flavour . These groups are called mutation types . Gremlins supports various mutation types , each comprising one or more mutations. When Gremlins scans the source code under test, it looks for mutations and for each found mutation creates a mutant . A mutant is the \"gremlin\" that actually changes the source code. Each mutant type can be enabled or disabled, and only a subset of mutations is enabled by default. MutationType Default ARITHMETIC BASE YES CONDITIONALS BOUNDARY YES CONDITIONALS NEGATION YES INCREMENT DECREMENT YES INVERT NEGATIVES YES","title":"About Mutations"},{"location":"usage/mutations/about/#about-mutations","text":"Mutations are the core of Gremlins' activity. Each mutation belongs to a group that defines its flavour . These groups are called mutation types . Gremlins supports various mutation types , each comprising one or more mutations. When Gremlins scans the source code under test, it looks for mutations and for each found mutation creates a mutant . A mutant is the \"gremlin\" that actually changes the source code. Each mutant type can be enabled or disabled, and only a subset of mutations is enabled by default. MutationType Default ARITHMETIC BASE YES CONDITIONALS BOUNDARY YES CONDITIONALS NEGATION YES INCREMENT DECREMENT YES INVERT NEGATIVES YES","title":"About Mutations"},{"location":"usage/mutations/arithmetic_base/","text":"Arithmetic base \u00b6 Arithmetic base will perform inversions on basic arithmetic operations. Mutation table \u00b6 Original Mutated + - - + * / / * % * Examples \u00b6 Original Mutated a := 1 + 2 a := 1 - 2","title":"Arithmetic base"},{"location":"usage/mutations/arithmetic_base/#arithmetic-base","text":"Arithmetic base will perform inversions on basic arithmetic operations.","title":"Arithmetic base"},{"location":"usage/mutations/arithmetic_base/#mutation-table","text":"Original Mutated + - - + * / / * % *","title":"Mutation table"},{"location":"usage/mutations/arithmetic_base/#examples","text":"Original Mutated a := 1 + 2 a := 1 - 2","title":"Examples"},{"location":"usage/mutations/conditionals_boundary/","text":"Conditionals boundaries \u00b6 Conditionals boundaries modify the boundary of a conditional, which means that exclusive/inclusive ranges will be inverted. Mutation table \u00b6 Original Mutated > >= >= > < <= <= < Examples \u00b6 Original Mutated if a > b { // Do something } if a >= b { // Do something }","title":"Conditionals boundaries"},{"location":"usage/mutations/conditionals_boundary/#conditionals-boundaries","text":"Conditionals boundaries modify the boundary of a conditional, which means that exclusive/inclusive ranges will be inverted.","title":"Conditionals boundaries"},{"location":"usage/mutations/conditionals_boundary/#mutation-table","text":"Original Mutated > >= >= > < <= <= <","title":"Mutation table"},{"location":"usage/mutations/conditionals_boundary/#examples","text":"Original Mutated if a > b { // Do something } if a >= b { // Do something }","title":"Examples"},{"location":"usage/mutations/conditionals_negation/","text":"Conditionals negation \u00b6 Conditionals negation inverts the conditional direction, which means a == will become a != . Mutation table \u00b6 Original Mutated == != != == > \\<= <= > < >= >= < Examples \u00b6 Original Mutated if a == b { // Do something } if a != b { // Do something }","title":"Conditionals negation"},{"location":"usage/mutations/conditionals_negation/#conditionals-negation","text":"Conditionals negation inverts the conditional direction, which means a == will become a != .","title":"Conditionals negation"},{"location":"usage/mutations/conditionals_negation/#mutation-table","text":"Original Mutated == != != == > \\<= <= > < >= >= <","title":"Mutation table"},{"location":"usage/mutations/conditionals_negation/#examples","text":"Original Mutated if a == b { // Do something } if a != b { // Do something }","title":"Examples"},{"location":"usage/mutations/increment_decrement/","text":"Increment decrement \u00b6 Increment decrement will invert the sign of the increment or decrement. Mutation table \u00b6 Original Mutated ++ -- -- ++ Examples \u00b6 Original Mutated for i := 0 ; i < 10 ; i ++ { // Do something } for i := 0 ; i < 10 ; i -- { // Do something }","title":"Increment decrement"},{"location":"usage/mutations/increment_decrement/#increment-decrement","text":"Increment decrement will invert the sign of the increment or decrement.","title":"Increment decrement"},{"location":"usage/mutations/increment_decrement/#mutation-table","text":"Original Mutated ++ -- -- ++","title":"Mutation table"},{"location":"usage/mutations/increment_decrement/#examples","text":"Original Mutated for i := 0 ; i < 10 ; i ++ { // Do something } for i := 0 ; i < 10 ; i -- { // Do something }","title":"Examples"},{"location":"usage/mutations/invert_negatives/","text":"Invert negatives \u00b6 Invert negatives will invert the sign of negative numbers, making them positive. Mutation table \u00b6 Original Mutated - + Examples \u00b6 Original Mutated func makeNegative ( i int ) int { return - i } func makeNegative ( i int ) int { return + i }","title":"Invert negatives"},{"location":"usage/mutations/invert_negatives/#invert-negatives","text":"Invert negatives will invert the sign of negative numbers, making them positive.","title":"Invert negatives"},{"location":"usage/mutations/invert_negatives/#mutation-table","text":"Original Mutated - +","title":"Mutation table"},{"location":"usage/mutations/invert_negatives/#examples","text":"Original Mutated func makeNegative ( i int ) int { return - i } func makeNegative ( i int ) int { return + i }","title":"Examples"}]}