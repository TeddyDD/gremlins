{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Gremlins \u00b6 Gremlins is a mutation testing tool for Go. It has been made to work well on smallish Go modules, for example microservices , on which it helps validate the test suite, aids the TDD process and can be used as a CI quality gate. As of now, Gremlins doesn't work very well on very big Go modules, mainly because a run can take hours to complete. What is Mutation Testing \u00b6 Code coverage is unreliable as a measure of test quality. It is too easy to have tests that exercise a piece of code but don't test anything at all. Mutation testing works by mutating the code exercised by the tests and verifying if the mutation is caught by the test suite. Imagine gremlins going into your code and messing around: will your test suit catch their damage? Features \u00b6 Discovers mutant candidates and tests them Only tests mutants covered by tests Supports five mutant types Yaml-based configuration Can run as quality gate on CI","title":"Home"},{"location":"#welcome-to-gremlins","text":"Gremlins is a mutation testing tool for Go. It has been made to work well on smallish Go modules, for example microservices , on which it helps validate the test suite, aids the TDD process and can be used as a CI quality gate. As of now, Gremlins doesn't work very well on very big Go modules, mainly because a run can take hours to complete.","title":"Welcome to Gremlins"},{"location":"#what-is-mutation-testing","text":"Code coverage is unreliable as a measure of test quality. It is too easy to have tests that exercise a piece of code but don't test anything at all. Mutation testing works by mutating the code exercised by the tests and verifying if the mutation is caught by the test suite. Imagine gremlins going into your code and messing around: will your test suit catch their damage?","title":"What is Mutation Testing"},{"location":"#features","text":"Discovers mutant candidates and tests them Only tests mutants covered by tests Supports five mutant types Yaml-based configuration Can run as quality gate on CI","title":"Features"},{"location":"install/","text":"Install \u00b6 Gremlins can be installed via pre-compiled binaries or from source. Pre compiled binaries \u00b6 Linux \u00b6 We don't have public repositories yet. To install, you have to download the package appropriate to your architecture/OS and install it \"manually\". deb rpm Download a .deb file appropriate for your ARCH from the release page , the install with: dpkg -i package.deb Download a .rpm file appropriate for your ARCH from the release page , the install with: rpm -i package.rpm MacOS \u00b6 On macOS, you can use Homebrew . As of now, Gremlins uses only an Homebrew tap . To install, you have to first tap Gremlins' repository: brew tap go-gremlins/tap #(1) Doing this, your tap will refer directly to the Gremlins' tap formula on GitHub. You can delete the tap by \"untapping\" it: brew untap go-gremlins/tap Then you can install it: brew install gremlins Windows \u00b6 As of now, only manual installation is supported. Download the appropriate release package from the release page , extract the zip archive and copy the .exe file somewhere in your execution PATH . Manual install \u00b6 Alternatively, you can download the binary for your ARCH/OS, untar it: tar -xvf gremlins_XXX.tar.gz then copy it somewhere in PATH : sudo cp gremlins_XXX/gremlins /usr/bin From source \u00b6 To build Gremlins you need the Go compiler , make and golangci-lint for linting. You can clone download the source tarball from the release page , then: tar -xvf gremlins_vXXX.tar.gz Ad then: cd gremlins make At this point, you can move the generated binary executable to a location of your choice.","title":"Install"},{"location":"install/#install","text":"Gremlins can be installed via pre-compiled binaries or from source.","title":"Install"},{"location":"install/#pre-compiled-binaries","text":"","title":"Pre compiled binaries"},{"location":"install/#linux","text":"We don't have public repositories yet. To install, you have to download the package appropriate to your architecture/OS and install it \"manually\". deb rpm Download a .deb file appropriate for your ARCH from the release page , the install with: dpkg -i package.deb Download a .rpm file appropriate for your ARCH from the release page , the install with: rpm -i package.rpm","title":"Linux"},{"location":"install/#macos","text":"On macOS, you can use Homebrew . As of now, Gremlins uses only an Homebrew tap . To install, you have to first tap Gremlins' repository: brew tap go-gremlins/tap #(1) Doing this, your tap will refer directly to the Gremlins' tap formula on GitHub. You can delete the tap by \"untapping\" it: brew untap go-gremlins/tap Then you can install it: brew install gremlins","title":"MacOS"},{"location":"install/#windows","text":"As of now, only manual installation is supported. Download the appropriate release package from the release page , extract the zip archive and copy the .exe file somewhere in your execution PATH .","title":"Windows"},{"location":"install/#manual-install","text":"Alternatively, you can download the binary for your ARCH/OS, untar it: tar -xvf gremlins_XXX.tar.gz then copy it somewhere in PATH : sudo cp gremlins_XXX/gremlins /usr/bin","title":"Manual install"},{"location":"install/#from-source","text":"To build Gremlins you need the Go compiler , make and golangci-lint for linting. You can clone download the source tarball from the release page , then: tar -xvf gremlins_vXXX.tar.gz Ad then: cd gremlins make At this point, you can move the generated binary executable to a location of your choice.","title":"From source"},{"location":"quick-start/","text":"Quick start \u00b6 To execute a mutation test run, from the root of a Go module execute: $ gremlins unleash #(1) If unleash is too long to type for you, you can use run or r which will do the same. Gremlins only tests mutations of parts of the code already covered by test cases. If a mutant is not covered, why bother testing? You already know it will not be caught. In any case, Gremlins will report which mutations aren't covered. Gremlins will report each mutation as: RUNNABLE : In dry-run mode, a mutation that can be tested. NOT COVERED : A mutation not covered by tests; it will not be tested. KILLED : The mutation has been caught by the test suite. LIVED : The mutation hasn't been caught by the test suite. TIMED OUT : The tests timed out while testing the mutation: the mutation actually made the tests fail, but not explicitly. NOT VIABLE : The mutation makes the build fail.","title":"Quick start"},{"location":"quick-start/#quick-start","text":"To execute a mutation test run, from the root of a Go module execute: $ gremlins unleash #(1) If unleash is too long to type for you, you can use run or r which will do the same. Gremlins only tests mutations of parts of the code already covered by test cases. If a mutant is not covered, why bother testing? You already know it will not be caught. In any case, Gremlins will report which mutations aren't covered. Gremlins will report each mutation as: RUNNABLE : In dry-run mode, a mutation that can be tested. NOT COVERED : A mutation not covered by tests; it will not be tested. KILLED : The mutation has been caught by the test suite. LIVED : The mutation hasn't been caught by the test suite. TIMED OUT : The tests timed out while testing the mutation: the mutation actually made the tests fail, but not explicitly. NOT VIABLE : The mutation makes the build fail.","title":"Quick start"},{"location":"usage/configuration/","text":"Configuration \u00b6 Gremlins can be configured via (in order of precedence): command flags environment variables configuration files Command flags \u00b6 Flags have the higher priority and override all the other means of setting behaviours. Please refer to the specific command documentation to learn how to use them. Configuration files \u00b6 Gremlins can be configured with a configuration file. Location \u00b6 The configuration file can be placed in (in order of precedence) ./.gremlins.yaml (the current directory) /etc/gremlins/gremlins.yaml $XDG_CONFIG_HOME/gremlins/gremlins.yaml $HOME/.gremlins.yaml Hint XDG_CONFIG_HOME is usually ~/.config . Override \u00b6 The config file can be overridden with the --config flag. gremlins unleash --config = myConfig.yaml Reference \u00b6 Here is a complete configuration file with all the properties set to their defaults: unleash : dry-run : false tags : \"\" threshold : #(1) efficacy : 0 mutant-coverage : 0 mutants : arithmetic-base : enabled : true conditionals-boundary : enabled : true conditionals-negation : enabled : true increment-decrement : enabled : true invert-negatives : enabled : true Thresholds are set by default to 0 , which means they are not enforced. For further information check the specific documentation. Environment variables \u00b6 Gremlins can be configured via environment variables as well. You can construct the variable name referring to the configuration file format. They start with GREMLINS_ , and each dot and dash becomes an underscore. For example: mutants : arithmetic-base : enabled : true Can be set with: export GREMLINS_MUTANTS_ARITHMETIC_BASE = true","title":"Configuration"},{"location":"usage/configuration/#configuration","text":"Gremlins can be configured via (in order of precedence): command flags environment variables configuration files","title":"Configuration"},{"location":"usage/configuration/#command-flags","text":"Flags have the higher priority and override all the other means of setting behaviours. Please refer to the specific command documentation to learn how to use them.","title":"Command flags"},{"location":"usage/configuration/#configuration-files","text":"Gremlins can be configured with a configuration file.","title":"Configuration files"},{"location":"usage/configuration/#location","text":"The configuration file can be placed in (in order of precedence) ./.gremlins.yaml (the current directory) /etc/gremlins/gremlins.yaml $XDG_CONFIG_HOME/gremlins/gremlins.yaml $HOME/.gremlins.yaml Hint XDG_CONFIG_HOME is usually ~/.config .","title":"Location"},{"location":"usage/configuration/#override","text":"The config file can be overridden with the --config flag. gremlins unleash --config = myConfig.yaml","title":"Override"},{"location":"usage/configuration/#reference","text":"Here is a complete configuration file with all the properties set to their defaults: unleash : dry-run : false tags : \"\" threshold : #(1) efficacy : 0 mutant-coverage : 0 mutants : arithmetic-base : enabled : true conditionals-boundary : enabled : true conditionals-negation : enabled : true increment-decrement : enabled : true invert-negatives : enabled : true Thresholds are set by default to 0 , which means they are not enforced. For further information check the specific documentation.","title":"Reference"},{"location":"usage/configuration/#environment-variables","text":"Gremlins can be configured via environment variables as well. You can construct the variable name referring to the configuration file format. They start with GREMLINS_ , and each dot and dash becomes an underscore. For example: mutants : arithmetic-base : enabled : true Can be set with: export GREMLINS_MUTANTS_ARITHMETIC_BASE = true","title":"Environment variables"},{"location":"usage/commands/gremlins/","text":"Gremlins \u00b6 The gremlins command works with command and flags. Think of commands as verbs and flags as adjectives. gremlins <command> [ flags ] If you type gremlins a short usage summary will be printed. At any time, you can get further help writing gremlins help <command> Global flags \u00b6 Global flags are not command specific. Config \u00b6 --config \u00b7 Default: empty Overrides the configuration file. gremlins <command> --config = config.yml","title":"Gremlins"},{"location":"usage/commands/gremlins/#gremlins","text":"The gremlins command works with command and flags. Think of commands as verbs and flags as adjectives. gremlins <command> [ flags ] If you type gremlins a short usage summary will be printed. At any time, you can get further help writing gremlins help <command>","title":"Gremlins"},{"location":"usage/commands/gremlins/#global-flags","text":"Global flags are not command specific.","title":"Global flags"},{"location":"usage/commands/gremlins/#config","text":"--config \u00b7 Default: empty Overrides the configuration file. gremlins <command> --config = config.yml","title":"Config"},{"location":"usage/commands/unleash/","text":"Unleash \u00b6 The main command used in Gremlins is unleash , that unleashes the gremlins and starts a mutation test of your code. If unleash is too long to type for you, you can use its aliases run and r . Warning At this time, this only works in the root of a Go module (where the go.mod file resides). To execute a mutation testing run just type gremlins unleash If the module build requires tags gremlins unleash --tags \"tag1,tag2\" Flags \u00b6 unleash supports several flags to fine tune its behaviour. Dry run \u00b6 --dry-run \u00b7 Default: false Just performs the analysis but not the mutation testing. gremlins unleash --dry-run Tags \u00b6 --tags / -t \u00b7 Default: empty Sets the go command build tags. gremlins unleash --tags \"tag1,tag2\" Threshold efficacy \u00b6 --threshold-efficacy \u00b7 Default: 0 When set, it makes Gremlins exit with an error (code 10) if the test efficacy threshold is not met. By default it is zero, which means Gremlins never exits with an error. The test efficacy is calculated as KILLED / (KILLED + LIVED) and assesses how effective are the tests. gremlins unleash --threshold-efficacy 80 Threshold mutant coverage \u00b6 --threshold-mcover \u00b7 Default: 0 When set, it makes Gremlins exit with an error (code 11) if the mutant coverage threshold is not met. By default it is zero, which means Gremlins never exits with an error. The mutant coverage is calculated as (KILLED + LIVED) / (KILLED + LIVED + NOT_COVERED) and assesses how many mutants are covered by tests. gremlins unleash --threshold-mcover 80 Arithmetic base \u00b6 --arithmetic-base \u00b7 Default: true Enables/disables the ARITHMETIC BASE mutant type. gremlins unleash --arithmetic-base = false Conditionals-boundary \u00b6 --conditionals-boundary \u00b7 Default: true Enables/disables the CONDITIONALS BOUNDARY mutant type. gremlins unleash --conditionals_boundary = false Conditionals negation \u00b6 --conditionals-negation \u00b7 Default: true Enables/disables the CONDITIONALS NEGATION mutant type. gremlins unleash --conditionals_negation = false Increment decrement \u00b6 --increment-decrement \u00b7 Default: true Enables/disables the INCREMENT DECREMENT mutant type. gremlins unleash --increment-decrement = false Invert negatives \u00b6 --invert-negatives \u00b7 Default: true Enables/disables the INVERT NEGATIVES mutant type. gremlins unleash --invert_negatives = false","title":"Unleash"},{"location":"usage/commands/unleash/#unleash","text":"The main command used in Gremlins is unleash , that unleashes the gremlins and starts a mutation test of your code. If unleash is too long to type for you, you can use its aliases run and r . Warning At this time, this only works in the root of a Go module (where the go.mod file resides). To execute a mutation testing run just type gremlins unleash If the module build requires tags gremlins unleash --tags \"tag1,tag2\"","title":"Unleash"},{"location":"usage/commands/unleash/#flags","text":"unleash supports several flags to fine tune its behaviour.","title":"Flags"},{"location":"usage/commands/unleash/#dry-run","text":"--dry-run \u00b7 Default: false Just performs the analysis but not the mutation testing. gremlins unleash --dry-run","title":"Dry run"},{"location":"usage/commands/unleash/#tags","text":"--tags / -t \u00b7 Default: empty Sets the go command build tags. gremlins unleash --tags \"tag1,tag2\"","title":"Tags"},{"location":"usage/commands/unleash/#threshold-efficacy","text":"--threshold-efficacy \u00b7 Default: 0 When set, it makes Gremlins exit with an error (code 10) if the test efficacy threshold is not met. By default it is zero, which means Gremlins never exits with an error. The test efficacy is calculated as KILLED / (KILLED + LIVED) and assesses how effective are the tests. gremlins unleash --threshold-efficacy 80","title":"Threshold efficacy"},{"location":"usage/commands/unleash/#threshold-mutant-coverage","text":"--threshold-mcover \u00b7 Default: 0 When set, it makes Gremlins exit with an error (code 11) if the mutant coverage threshold is not met. By default it is zero, which means Gremlins never exits with an error. The mutant coverage is calculated as (KILLED + LIVED) / (KILLED + LIVED + NOT_COVERED) and assesses how many mutants are covered by tests. gremlins unleash --threshold-mcover 80","title":"Threshold mutant coverage"},{"location":"usage/commands/unleash/#arithmetic-base","text":"--arithmetic-base \u00b7 Default: true Enables/disables the ARITHMETIC BASE mutant type. gremlins unleash --arithmetic-base = false","title":"Arithmetic base"},{"location":"usage/commands/unleash/#conditionals-boundary","text":"--conditionals-boundary \u00b7 Default: true Enables/disables the CONDITIONALS BOUNDARY mutant type. gremlins unleash --conditionals_boundary = false","title":"Conditionals-boundary"},{"location":"usage/commands/unleash/#conditionals-negation","text":"--conditionals-negation \u00b7 Default: true Enables/disables the CONDITIONALS NEGATION mutant type. gremlins unleash --conditionals_negation = false","title":"Conditionals negation"},{"location":"usage/commands/unleash/#increment-decrement","text":"--increment-decrement \u00b7 Default: true Enables/disables the INCREMENT DECREMENT mutant type. gremlins unleash --increment-decrement = false","title":"Increment decrement"},{"location":"usage/commands/unleash/#invert-negatives","text":"--invert-negatives \u00b7 Default: true Enables/disables the INVERT NEGATIVES mutant type. gremlins unleash --invert_negatives = false","title":"Invert negatives"},{"location":"usage/mutations/about/","text":"About Mutations \u00b6 Mutations are the core of Gremlins' activity. Each mutation belongs to a group that defines its flavour . These groups are called mutation types . Gremlins supports various mutation types , each comprising one or more mutations. When Gremlins scans the source code under test, it looks for mutations and for each found mutation creates a mutant . A mutant is the \"gremlin\" that actually changes the source code. Each mutant type can be enabled or disabled, and only a subset of mutations is enabled by default. MutationType Default ARITHMETIC BASE YES CONDITIONALS BOUNDARY YES CONDITIONALS NEGATION YES INCREMENT DECREMENT YES INVERT NEGATIVES YES","title":"About Mutations"},{"location":"usage/mutations/about/#about-mutations","text":"Mutations are the core of Gremlins' activity. Each mutation belongs to a group that defines its flavour . These groups are called mutation types . Gremlins supports various mutation types , each comprising one or more mutations. When Gremlins scans the source code under test, it looks for mutations and for each found mutation creates a mutant . A mutant is the \"gremlin\" that actually changes the source code. Each mutant type can be enabled or disabled, and only a subset of mutations is enabled by default. MutationType Default ARITHMETIC BASE YES CONDITIONALS BOUNDARY YES CONDITIONALS NEGATION YES INCREMENT DECREMENT YES INVERT NEGATIVES YES","title":"About Mutations"},{"location":"usage/mutations/arithmetic_base/","text":"Arithmetic base default \u00b6 Arithmetic base will perform inversions on basic arithmetic operations. Mutation table \u00b6 Original Mutated + - - + * / / * % * Examples \u00b6 Original Mutated a := 1 + 2 a := 1 - 2","title":"Arithmetic base"},{"location":"usage/mutations/arithmetic_base/#arithmetic-base-default","text":"Arithmetic base will perform inversions on basic arithmetic operations.","title":"Arithmetic base  default"},{"location":"usage/mutations/arithmetic_base/#mutation-table","text":"Original Mutated + - - + * / / * % *","title":"Mutation table"},{"location":"usage/mutations/arithmetic_base/#examples","text":"Original Mutated a := 1 + 2 a := 1 - 2","title":"Examples"},{"location":"usage/mutations/conditionals_boundary/","text":"Conditionals boundary default \u00b6 Conditionals boundaries modify the boundary of a conditional, which means that exclusive/inclusive ranges will be inverted. Mutation table \u00b6 Original Mutated > >= >= > < <= <= < Examples \u00b6 Original if a > b { // Do something } Mutated if a >= b { // Do something }","title":"Conditionals boundary"},{"location":"usage/mutations/conditionals_boundary/#conditionals-boundary-default","text":"Conditionals boundaries modify the boundary of a conditional, which means that exclusive/inclusive ranges will be inverted.","title":"Conditionals boundary  default"},{"location":"usage/mutations/conditionals_boundary/#mutation-table","text":"Original Mutated > >= >= > < <= <= <","title":"Mutation table"},{"location":"usage/mutations/conditionals_boundary/#examples","text":"Original if a > b { // Do something } Mutated if a >= b { // Do something }","title":"Examples"},{"location":"usage/mutations/conditionals_negation/","text":"Conditionals negation default \u00b6 Conditionals negation inverts the conditional direction, which means a == will become a != . Mutation table \u00b6 Original Mutated == != != == > \\<= <= > < >= >= < Examples \u00b6 Original if a == b { // Do something } Mutated if a != b { // Do something }","title":"Conditionals negation"},{"location":"usage/mutations/conditionals_negation/#conditionals-negation-default","text":"Conditionals negation inverts the conditional direction, which means a == will become a != .","title":"Conditionals negation  default"},{"location":"usage/mutations/conditionals_negation/#mutation-table","text":"Original Mutated == != != == > \\<= <= > < >= >= <","title":"Mutation table"},{"location":"usage/mutations/conditionals_negation/#examples","text":"Original if a == b { // Do something } Mutated if a != b { // Do something }","title":"Examples"},{"location":"usage/mutations/increment_decrement/","text":"Increment decrement default \u00b6 Increment decrement will invert the sign of the increment or decrement. Mutation table \u00b6 Original Mutated ++ -- -- ++ Examples \u00b6 Original for i := 0 ; i < 10 ; i ++ { // Do something } Mutated for i := 0 ; i < 10 ; i -- { // Do something }","title":"Increment decrement"},{"location":"usage/mutations/increment_decrement/#increment-decrement-default","text":"Increment decrement will invert the sign of the increment or decrement.","title":"Increment decrement  default"},{"location":"usage/mutations/increment_decrement/#mutation-table","text":"Original Mutated ++ -- -- ++","title":"Mutation table"},{"location":"usage/mutations/increment_decrement/#examples","text":"Original for i := 0 ; i < 10 ; i ++ { // Do something } Mutated for i := 0 ; i < 10 ; i -- { // Do something }","title":"Examples"},{"location":"usage/mutations/invert_negatives/","text":"Invert negatives default \u00b6 Invert negatives will invert the sign of negative numbers, making them positive. Mutation table \u00b6 Original Mutated - + Examples \u00b6 Original Mutated func makeNegative ( i int ) int { return - i } func makeNegative ( i int ) int { return + i }","title":"Invert negatives"},{"location":"usage/mutations/invert_negatives/#invert-negatives-default","text":"Invert negatives will invert the sign of negative numbers, making them positive.","title":"Invert negatives  default"},{"location":"usage/mutations/invert_negatives/#mutation-table","text":"Original Mutated - +","title":"Mutation table"},{"location":"usage/mutations/invert_negatives/#examples","text":"Original Mutated func makeNegative ( i int ) int { return - i } func makeNegative ( i int ) int { return + i }","title":"Examples"}]}